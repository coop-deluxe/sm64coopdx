#!/usr/bin/env python3
"""
codegen.py

Generate rom_offsets.c / rom_offsets.h from address_map.json for a chosen region.

Usage:
  python3 tools/codegen.py --map config/address_map.json --region US --out-dir generated
"""
import argparse
import json
import re
from pathlib import Path
import sys

HEX_RE = re.compile(r"^0x[0-9a-fA-F]+$")

def load_map(path):
    with open(path, "r", encoding="utf-8") as f:
        return json.load(f)

def parse_addr(a):
    if isinstance(a, int):
        return a
    if isinstance(a, str):
        s = a.strip()
        if HEX_RE.match(s):
            return int(s, 16)
        try:
            return int(s, 0)
        except Exception:
            raise ValueError(f"Unsupported address format: {a}")
    raise ValueError(f"Unsupported address type: {type(a)}")

def emit_h(out_path):
    out_path.write_text("""#pragma once
#include <stdint.h>
#include <stddef.h>

/* Generated rom_offsets header - DO NOT EDIT (generated by codegen.py) */
#ifdef __cplusplus
extern "C" {
#endif

/* Resolve a named symbol to a runtime pointer (0 if not found) */
uintptr_t rom_addr(const char *symbol);

/* Convenience macros */
#define ROM_FUNC(sym) ((void(*)())rom_addr(sym))
#define ROM_PTR(sym, type) (*(type*)rom_addr(sym))

#ifdef __cplusplus
}
#endif
""", encoding="utf-8")

def emit_c(out_path, symbols):
    entries = []
    for name, addr in symbols:
        cname = name.replace('"','\\"')
        entries.append(f'    {{ "{cname} ", (uintptr_t)0x{addr:08X} }}')

    table = ",\n".join(entries)
    content = f"""#include "rom_offsets.h"
#include <string.h>

/* Generated rom_offsets implementation - DO NOT EDIT (generated by codegen.py) */

typedef struct {{
    const char *name;
    uintptr_t addr;
}} sym_t;

static const sym_t rom_symbols[] = {{
{table}
}};

uintptr_t rom_addr(const char *symbol) {{
    if (!symbol) return 0;
    for (size_t i = 0; i < sizeof(rom_symbols)/sizeof(rom_symbols[0]); ++i) {{
        if (strcmp(rom_symbols[i].name, symbol) == 0) {{
            return rom_symbols[i].addr;
        }}
    }}
    return 0;
}}"""
    out_path.write_text(content, encoding="utf-8")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--map", required=True, help="Path to address_map.json")
    ap.add_argument("--region", required=True, help="Region code to generate (e.g. US, JP, EU)")
    ap.add_argument("--out-dir", default=".", help="Output directory")
    args = ap.parse_args()

    mpath = Path(args.map)
    if not mpath.exists():
        print("address_map.json not found:", mpath)
        sys.exit(2)
    j = load_map(mpath)
    regions = j.get("regions", {})
    if args.region not in regions:
        print("Region not found in address_map.json:", args.region)
        print("Available regions:", ", ".join(regions.keys()))
        sys.exit(3)
    region_obj = regions[args.region]
    addresses = region_obj.get("addresses", {})
    symbols = []
    for sym_name, addr_val in addresses.items():
        try:
            addr = parse_addr(addr_val)
        except ValueError as e:
            print("Skipping symbol (bad address):", sym_name, addr_val, "->", e)
            continue
        symbols.append((sym_name, addr))

    outdir = Path(args.out_dir)
    outdir.mkdir(parents=True, exist_ok=True)
    hpath = outdir / "rom_offsets.h"
    cpath = outdir / "rom_offsets.c"
    emit_h(hpath)
    emit_c(cpath, symbols)
    print("Wrote:", hpath, cpath)
    print("Include rom_offsets.h and link rom_offsets.c into your build.")
    print("Use rom_addr(\"SymbolName\") to resolve addresses at runtime.")
    
if __name__ == '__main__':
    main()